# 方案4-混合架构优化方案设计-第3章

## 3. 架构与依赖优化

### 3.1 模块职责重划

#### 3.1.1 HybridMarkdownRenderer职责重划

**当前问题**：
- 承担了太多职责：渲染、缓存、配置管理、文件解析协调
- 与ConfigManager耦合过紧
- 缓存管理职责与ContentPreview重复

**优化方案**：
```
重构前职责：
├── Markdown内容渲染
├── 渲染缓存管理
├── 配置选项管理
├── 文件路径解析协调
├── 动态模块导入协调
└── 错误处理和降级

重构后职责：
├── Markdown内容渲染（核心）
├── 渲染器选择策略
├── 渲染结果缓存
└── 渲染错误处理
```

**具体重构**：
1. **移除配置管理职责**：配置获取委托给专门的配置服务
2. **简化缓存职责**：只负责渲染结果缓存，不管理其他缓存
3. **专注渲染逻辑**：专注于Markdown到HTML的转换
4. **委托文件解析**：文件读取完全委托给FileResolver

#### 3.1.2 ConfigManager职责分离

**当前问题**：
- 被所有模块依赖，耦合度过高
- 承担了太多配置类型的管理
- 配置变更影响面过大

**优化方案**：
```
重构前职责：
├── 应用配置管理
├── UI配置管理
├── 文件类型配置管理
├── 外部模块配置管理
└── Markdown配置管理

重构后职责：
├── 应用配置管理（核心）
├── 配置变更通知
└── 配置验证和默认值
```

**新增配置服务**：
1. **FileTypeConfigService**：专门管理文件类型配置
2. **MarkdownConfigService**：专门管理Markdown相关配置
3. **ExternalModuleConfigService**：专门管理外部模块配置
4. **UIConfigService**：专门管理UI相关配置

#### 3.1.3 DynamicModuleImporter通用工具定位

**当前问题**：
- 被错误定位为HybridMarkdownRenderer的专用组件
- 接口设计不够通用
- 缺乏对其他模块类型的支持

**优化方案**：
```
重构前定位：
└── HybridMarkdownRenderer专用组件
    └── 仅支持markdown_processor导入

重构后定位：
└── 通用模块导入工具
    ├── 支持多种模块类型
    ├── 提供统一导入接口
    ├── 支持模块性能评分
    └── 支持热插拔和版本管理
```

**扩展支持**：
1. **LinkProcessor模块**：支持外部链接处理模块导入
2. **ContentPreview模块**：支持外部预览模块导入
3. **FileResolver模块**：支持外部文件解析模块导入
4. **通用扩展模块**：支持任意类型的扩展模块导入

### 3.2 依赖关系优化

#### 3.2.1 依赖关系重构图

```
重构前依赖关系：
MainWindow
├── FileTree
│   └── ConfigManager (全局依赖)
├── ContentViewer
│   ├── ContentPreview
│   │   ├── FileResolver
│   │   └── MarkdownRenderer
│   ├── FileResolver
│   └── MarkdownRenderer
│       ├── FileResolver
│       └── DynamicModuleImporter
└── ConfigManager (全局依赖)

重构后依赖关系：
MainWindow
├── FileTree
│   └── UIConfigService
├── ContentViewer
│   ├── ContentPreview
│   │   ├── FileResolver
│   │   ├── MarkdownRenderer
│   │   └── CacheManager
│   ├── FileResolver
│   ├── MarkdownRenderer
│   └── CacheManager
├── ConfigManager (核心配置)
├── CacheManager (统一缓存)
└── ServiceRegistry (服务注册)
```

#### 3.2.2 循环依赖消除

**当前循环依赖**：
1. HybridMarkdownRenderer ↔ ConfigManager
2. ContentPreview ↔ MarkdownRenderer
3. 多个模块 ↔ ConfigManager

**优化策略**：
1. **引入服务注册表**：ServiceRegistry管理所有服务实例
2. **依赖注入**：通过构造函数注入依赖，避免直接导入
3. **接口抽象**：定义接口契约，降低具体实现的依赖
4. **事件驱动**：使用事件机制解耦模块间通信

#### 3.2.3 配置依赖优化

**当前问题**：
- 所有模块都直接依赖ConfigManager
- 配置变更需要重启应用
- 配置结构变更影响所有模块

**优化方案**：
1. **配置服务化**：将配置管理拆分为多个专门的服务
2. **配置变更通知**：实现配置变更的事件通知机制
3. **配置热重载**：支持运行时配置重载
4. **配置验证**：实现配置变更前的验证机制

### 3.3 接口契约设计

#### 3.3.1 统一接口契约

**缓存接口契约**：
```python
class ICacheManager(Protocol):
    def get(self, key: str) -> Optional[Any]: ...
    def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool: ...
    def delete(self, key: str) -> bool: ...
    def clear(self) -> None: ...
    def get_stats(self) -> Dict[str, Any]: ...
    def is_enabled(self) -> bool: ...
```

**配置接口契约**：
```python
class IConfigService(Protocol):
    def get(self, key: str, default: Any = None) -> Any: ...
    def set(self, key: str, value: Any) -> bool: ...
    def has(self, key: str) -> bool: ...
    def reload(self) -> bool: ...
    def validate(self, config: Dict[str, Any]) -> ValidationResult: ...
```

**错误处理接口契约**：
```python
class IErrorHandler(Protocol):
    def handle_error(self, error: Exception, context: Dict[str, Any]) -> ErrorResult: ...
    def can_retry(self, error: Exception) -> bool: ...
    def get_fallback(self, context: Dict[str, Any]) -> Any: ...
    def log_error(self, error: Exception, context: Dict[str, Any]) -> None: ...
```

#### 3.3.2 接口版本管理

**版本兼容策略**：
1. **向后兼容**：新版本必须支持旧版本的接口调用
2. **渐进式废弃**：旧接口标记为废弃，但不立即移除
3. **版本检测**：运行时检测接口版本兼容性
4. **自动降级**：不兼容时自动降级到兼容版本

**接口演化规则**：
1. **新增方法**：允许添加新方法，不影响现有调用
2. **参数扩展**：新参数必须提供默认值
3. **返回值扩展**：新字段必须可选
4. **异常扩展**：新异常类型必须继承现有异常

### 3.4 服务注册表设计

#### 3.4.1 ServiceRegistry实现

**服务注册表核心功能**：
```python
class ServiceRegistry:
    def __init__(self):
        self._services = {}
        self._service_factories = {}
        self._dependencies = {}
    
    def register_service(self, service_name: str, service_instance: Any):
        """注册服务实例"""
        self._services[service_name] = service_instance
    
    def register_factory(self, service_name: str, factory: Callable):
        """注册服务工厂"""
        self._service_factories[service_name] = factory
    
    def get_service(self, service_name: str) -> Any:
        """获取服务实例"""
        if service_name in self._services:
            return self._services[service_name]
        
        if service_name in self._service_factories:
            service = self._service_factories[service_name]()
            self._services[service_name] = service
            return service
        
        raise ServiceNotFoundError(f"Service {service_name} not found")
    
    def has_service(self, service_name: str) -> bool:
        """检查服务是否存在"""
        return service_name in self._services or service_name in self._service_factories
```

#### 3.4.2 依赖注入容器

**依赖注入实现**：
```python
class DependencyInjector:
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry
    
    def inject_dependencies(self, target_class: Type, **kwargs):
        """注入依赖到目标类"""
        # 分析构造函数参数
        import inspect
        sig = inspect.signature(target_class.__init__)
        
        # 构建参数
        params = {}
        for param_name, param in sig.parameters.items():
            if param_name == 'self':
                continue
            
            if param_name in kwargs:
                params[param_name] = kwargs[param_name]
            elif param.annotation != inspect.Parameter.empty:
                # 尝试从服务注册表获取
                try:
                    service_name = param.annotation.__name__.lower()
                    if self.service_registry.has_service(service_name):
                        params[param_name] = self.service_registry.get_service(service_name)
                except:
                    pass
        
        return target_class(**params)
```

---

**文件状态**: 第3章完成 ✅  
**内容行数**: 约450行  
**下一步**: 生成第4-6章-机制优化设计 