# 方案4-混合架构优化方案设计-第7章

## 7. 可观测性增强

### 7.1 日志框架

#### 7.1.1 结构化日志设计

**日志格式标准化**：
```python
class StructuredLogger:
    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = config
        self.logger = logging.getLogger(name)
        self._setup_formatter()
    
    def _setup_formatter(self):
        formatter = logging.Formatter(
            '%(asctime)s | %(name)s | %(levelname)s | %(session_id)s | %(operation)s | %(message)s'
        )
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
    
    def log_operation(self, level: str, operation: str, message: str, **kwargs):
        extra = {
            'session_id': kwargs.get('session_id', 'unknown'),
            'operation': operation,
            'duration_ms': kwargs.get('duration_ms', 0),
            'file_path': kwargs.get('file_path', ''),
            'file_size': kwargs.get('file_size', 0),
            'cache_hit': kwargs.get('cache_hit', False),
            'error_code': kwargs.get('error_code', ''),
            'renderer_type': kwargs.get('renderer_type', ''),
            **kwargs
        }
        
        log_method = getattr(self.logger, level.lower())
        log_method(message, extra=extra)
```

**日志级别管理**：
```python
class LogLevelManager:
    def __init__(self):
        self.module_levels = {}
        self.performance_thresholds = {}
    
    def set_module_level(self, module_name: str, level: str):
        """设置模块日志级别"""
        self.module_levels[module_name] = level
        logger = logging.getLogger(module_name)
        logger.setLevel(getattr(logging, level.upper()))
    
    def adjust_level_by_performance(self, module_name: str, performance_metric: float):
        """根据性能指标调整日志级别"""
        if performance_metric < self.performance_thresholds.get(module_name, 0.5):
            # 性能差时降低日志级别，减少开销
            self.set_module_level(module_name, 'WARNING')
        else:
            # 性能好时提高日志级别，增加详细信息
            self.set_module_level(module_name, 'DEBUG')
    
    def get_effective_level(self, module_name: str) -> str:
        """获取模块的有效日志级别"""
        return self.module_levels.get(module_name, 'INFO')
```

#### 7.1.2 日志轮转和归档

**智能日志轮转**：
```python
class SmartLogRotator:
    def __init__(self, max_size_mb: int = 100, max_files: int = 5):
        self.max_size_bytes = max_size_mb * 1024 * 1024
        self.max_files = max_files
        self.current_log_size = 0
    
    def should_rotate(self, log_file_path: Path) -> bool:
        """判断是否需要轮转日志"""
        if not log_file_path.exists():
            return False
        
        current_size = log_file_path.stat().st_size
        return current_size > self.max_size_bytes
    
    def rotate_logs(self, log_file_path: Path):
        """执行日志轮转"""
        if not self.should_rotate(log_file_path):
            return
        
        # 重命名现有日志文件
        for i in range(self.max_files - 1, 0, -1):
            old_name = f"{log_file_path}.{i}"
            new_name = f"{log_file_path}.{i + 1}"
            
            if Path(old_name).exists():
                if i == self.max_files - 1:
                    Path(old_name).unlink()  # 删除最旧的日志
                else:
                    Path(old_name).rename(new_name)
        
        # 重命名当前日志文件
        current_log = f"{log_file_path}.1"
        log_file_path.rename(current_log)
        
        # 创建新的日志文件
        log_file_path.touch()
```

### 7.2 监控指标

#### 7.2.1 性能指标收集

**核心性能指标**：
```python
class PerformanceMetrics:
    def __init__(self):
        self.metrics = {
            'file_read_time': [],
            'render_time': [],
            'cache_hit_rate': [],
            'memory_usage': [],
            'error_rate': [],
            'throughput': []
        }
        self._start_time = time.time()
        self._metric_locks = {name: threading.Lock() for name in self.metrics}
    
    def record_metric(self, metric_name: str, value: float):
        """记录性能指标"""
        if metric_name not in self.metrics:
            return
        
        with self._metric_locks[metric_name]:
            self.metrics[metric_name].append({
                'value': value,
                'timestamp': time.time()
            })
            # 保持最近1000个数据点
            if len(self.metrics[metric_name]) > 1000:
                self.metrics[metric_name] = self.metrics[metric_name][-1000:]
    
    def get_statistics(self, metric_name: str) -> Dict[str, float]:
        """获取指标统计信息"""
        if metric_name not in self.metrics:
            return {}
        
        with self._metric_locks[metric_name]:
            values = [m['value'] for m in self.metrics[metric_name]]
            if not values:
                return {}
            
            return {
                'count': len(values),
                'min': min(values),
                'max': max(values),
                'mean': sum(values) / len(values),
                'median': sorted(values)[len(values) // 2],
                'p95': sorted(values)[int(len(values) * 0.95)],
                'p99': sorted(values)[int(len(values) * 0.99)]
            }
    
    def get_recent_trend(self, metric_name: str, window_minutes: int = 10) -> Dict[str, float]:
        """获取最近的趋势数据"""
        if metric_name not in self.metrics:
            return {}
        
        cutoff_time = time.time() - (window_minutes * 60)
        
        with self._metric_locks[metric_name]:
            recent_values = [
                m['value'] for m in self.metrics[metric_name] 
                if m['timestamp'] > cutoff_time
            ]
            
            if not recent_values:
                return {}
            
            return {
                'recent_count': len(recent_values),
                'recent_mean': sum(recent_values) / len(recent_values),
                'trend': self._calculate_trend(recent_values)
            }
    
    def _calculate_trend(self, values: List[float]) -> str:
        """计算趋势（上升/下降/稳定）"""
        if len(values) < 2:
            return 'stable'
        
        # 简单的线性回归斜率
        x = list(range(len(values)))
        y = values
        
        n = len(x)
        sum_x = sum(x)
        sum_y = sum(y)
        sum_xy = sum(x[i] * y[i] for i in range(n))
        sum_x2 = sum(x[i] ** 2 for i in range(n))
        
        slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x ** 2)
        
        if abs(slope) < 0.01:
            return 'stable'
        elif slope > 0:
            return 'increasing'
        else:
            return 'decreasing'
```

#### 7.2.2 实时监控面板

**监控数据展示**：
```python
class MonitoringDashboard:
    def __init__(self, performance_metrics: PerformanceMetrics):
        self.metrics = performance_metrics
        self.alert_thresholds = {
            'file_read_time': 1000,  # 1秒
            'render_time': 500,       # 500毫秒
            'cache_hit_rate': 0.8,    # 80%
            'memory_usage': 0.9,      # 90%
            'error_rate': 0.05        # 5%
        }
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """获取仪表板数据"""
        dashboard_data = {}
        
        for metric_name in self.metrics.metrics:
            stats = self.metrics.get_statistics(metric_name)
            recent_trend = self.metrics.get_recent_trend(metric_name)
            
            dashboard_data[metric_name] = {
                'current': stats.get('mean', 0),
                'trend': recent_trend.get('trend', 'stable'),
                'alert': self._check_alert(metric_name, stats),
                'history': self._get_recent_history(metric_name)
            }
        
        return dashboard_data
    
    def _check_alert(self, metric_name: str, stats: Dict[str, float]) -> Dict[str, Any]:
        """检查是否需要告警"""
        threshold = self.alert_thresholds.get(metric_name)
        if not threshold:
            return {'alert': False}
        
        current_value = stats.get('mean', 0)
        
        if metric_name in ['cache_hit_rate']:
            # 对于比率类指标，值越高越好
            alert = current_value < threshold
            severity = 'warning' if alert else 'normal'
        else:
            # 对于时间类指标，值越低越好
            alert = current_value > threshold
            severity = 'critical' if alert else 'normal'
        
        return {
            'alert': alert,
            'severity': severity,
            'threshold': threshold,
            'current': current_value
        }
    
    def _get_recent_history(self, metric_name: str, points: int = 20) -> List[Dict[str, Any]]:
        """获取最近的历史数据点"""
        if metric_name not in self.metrics.metrics:
            return []
        
        with self.metrics._metric_locks[metric_name]:
            recent_data = self.metrics.metrics[metric_name][-points:]
            return [
                {
                    'timestamp': m['timestamp'],
                    'value': m['value']
                }
                for m in recent_data
            ]
```

### 7.3 调试能力

#### 7.3.1 调试信息增强

**调试上下文管理**：
```python
class DebugContext:
    def __init__(self):
        self.context_stack = []
        self.variables = {}
        self.call_stack = []
        self.context_id = str(uuid.uuid4())
    
    def push_context(self, context_name: str, **kwargs):
        """推入调试上下文"""
        context = {
            'name': context_name,
            'timestamp': time.time(),
            'variables': kwargs.copy(),
            'call_stack': traceback.extract_stack(),
            'context_id': f"{self.context_id}_{len(self.context_stack)}"
        }
        self.context_stack.append(context)
    
    def pop_context(self) -> Optional[Dict[str, Any]]:
        """弹出调试上下文"""
        return self.context_stack.pop() if self.context_stack else None
    
    def get_current_context(self) -> Dict[str, Any]:
        """获取当前调试上下文"""
        if not self.context_stack:
            return {}
        
        current = self.context_stack[-1].copy()
        current['stack_depth'] = len(self.context_stack)
        return current
    
    def get_context_info(self) -> str:
        """获取调试上下文信息"""
        if not self.context_stack:
            return "No debug context"
        
        info = []
        for i, context in enumerate(reversed(self.context_stack)):
            info.append(f"Level {i}: {context['name']} (ID: {context['context_id']})")
            for key, value in context['variables'].items():
                info.append(f"  {key}: {value}")
        
        return '\n'.join(info)
    
    def export_context(self) -> Dict[str, Any]:
        """导出调试上下文"""
        return {
            'context_id': self.context_id,
            'stack_depth': len(self.context_stack),
            'contexts': [
                {
                    'name': ctx['name'],
                    'timestamp': ctx['timestamp'],
                    'variables': ctx['variables'],
                    'context_id': ctx['context_id']
                }
                for ctx in self.context_stack
            ],
            'global_variables': self.variables.copy()
        }
```

#### 7.3.2 性能分析工具

**性能分析功能**：
```python
class PerformanceProfiler:
    def __init__(self):
        self.function_timings = defaultdict(list)
        self.function_calls = defaultdict(int)
        self.memory_snapshots = []
        self.profiling_enabled = False
    
    def start_profiling(self):
        """开始性能分析"""
        self.profiling_enabled = True
        self.function_timings.clear()
        self.function_calls.clear()
        self.memory_snapshots.clear()
    
    def stop_profiling(self):
        """停止性能分析"""
        self.profiling_enabled = False
    
    def profile_function(self, func_name: str):
        """函数性能分析装饰器"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                if not self.profiling_enabled:
                    return func(*args, **kwargs)
                
                start_time = time.time()
                start_memory = self._get_memory_usage()
                
                try:
                    result = func(*args, **kwargs)
                    return result
                finally:
                    end_time = time.time()
                    end_memory = self._get_memory_usage()
                    
                    duration = (end_time - start_time) * 1000  # 转换为毫秒
                    memory_delta = end_memory - start_memory
                    
                    self.function_timings[func_name].append(duration)
                    self.function_calls[func_name] += 1
                    
                    # 记录内存快照
                    self.memory_snapshots.append({
                        'timestamp': end_time,
                        'function': func_name,
                        'memory_usage': end_memory,
                        'memory_delta': memory_delta
                    })
            
            return wrapper
        return decorator
    
    def get_performance_report(self) -> Dict[str, Any]:
        """获取性能分析报告"""
        report = {}
        
        for func_name, timings in self.function_timings.items():
            if timings:
                report[func_name] = {
                    'call_count': self.function_calls[func_name],
                    'total_time_ms': sum(timings),
                    'avg_time_ms': sum(timings) / len(timings),
                    'min_time_ms': min(timings),
                    'max_time_ms': max(timings),
                    'p95_time_ms': sorted(timings)[int(len(timings) * 0.95)]
                }
        
        return report
    
    def _get_memory_usage(self) -> int:
        """获取当前内存使用量（字节）"""
        try:
            import psutil
            process = psutil.Process()
            return process.memory_info().rss
        except ImportError:
            return 0
```

---

**文件状态**: 第7章完成 ✅  
**内容行数**: 约450行  
**下一步**: 生成第8章-链接处理模块集成 