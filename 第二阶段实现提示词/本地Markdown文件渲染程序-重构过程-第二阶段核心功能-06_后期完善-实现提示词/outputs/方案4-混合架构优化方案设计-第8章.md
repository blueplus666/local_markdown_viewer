# 方案4-混合架构优化方案设计-第8章

## 8. 链接处理模块集成

### 8.1 集成架构设计

#### 8.1.1 模块集成关系

**集成架构图**：
```
重构后的架构：
MainWindow
├── FileTree
│   └── UIConfigService
├── ContentViewer
│   ├── ContentPreview
│   │   ├── FileResolver
│   │   ├── MarkdownRenderer
│   │   ├── CacheManager
│   │   └── LinkProcessor (新增集成)
│   ├── FileResolver
│   ├── MarkdownRenderer
│   ├── CacheManager
│   └── LinkProcessor (新增集成)
├── ConfigManager (核心配置)
├── CacheManager (统一缓存)
├── ServiceRegistry (服务注册)
└── LinkProcessor (独立模块)
    ├── LinkResolver
    ├── LinkValidator
    ├── LinkCache
    └── ExternalLinkHandler
```

**集成方式**：
1. **服务注册表集成**：LinkProcessor通过ServiceRegistry注册为服务
2. **依赖注入集成**：MarkdownRenderer通过构造函数注入LinkProcessor
3. **事件驱动集成**：通过事件机制处理链接相关操作
4. **接口契约集成**：通过统一的接口定义实现松耦合

#### 8.1.2 接口契约定义

**链接处理接口**：
```python
class ILinkProcessor(Protocol):
    def process_links(self, content: str, file_path: Path) -> ProcessedContent: ...
    def resolve_link(self, link: str, base_path: Path) -> ResolvedLink: ...
    def validate_link(self, link: str) -> LinkValidationResult: ...
    def get_link_info(self, link: str) -> LinkInfo: ...
    def update_links(self, content: str, old_path: Path, new_path: Path) -> str: ...

@dataclass
class ProcessedContent:
    content: str
    links: List[LinkInfo]
    warnings: List[str]
    processing_time_ms: float
    cache_hit: bool

@dataclass
class ResolvedLink:
    original_link: str
    resolved_path: Optional[Path]
    link_type: LinkType
    is_valid: bool
    error_message: Optional[str]
    metadata: Dict[str, Any]

@dataclass
class LinkValidationResult:
    is_valid: bool
    validation_errors: List[str]
    warnings: List[str]
    link_type: LinkType
    security_level: SecurityLevel
    access_permissions: AccessPermissions

@dataclass
class LinkInfo:
    link_text: str
    link_url: str
    link_type: LinkType
    line_number: int
    column_number: int
    context: str
    is_valid: bool
    validation_errors: List[str]
```

### 8.2 核心功能集成

#### 8.2.1 Markdown渲染器集成

**渲染器集成实现**：
```python
class EnhancedMarkdownRenderer:
    def __init__(self, link_processor: ILinkProcessor, cache_manager: ICacheManager):
        self.link_processor = link_processor
        self.cache_manager = cache_manager
        self.render_cache = cache_manager.get_cache('render')
    
    def render_markdown(self, content: str, file_path: Path, options: Dict[str, Any] = None) -> RenderResult:
        """增强的Markdown渲染，集成链接处理"""
        start_time = time.time()
        
        # 检查缓存
        cache_key = self._generate_cache_key(content, file_path, options)
        cached_result = self.render_cache.get(cache_key)
        if cached_result:
            return RenderResult(
                html=cached_result['html'],
                links=cached_result['links'],
                processing_time_ms=0,
                cache_hit=True
            )
        
        try:
            # 预处理链接
            processed_content = self.link_processor.process_links(content, file_path)
            
            # 渲染Markdown
            html_content = self._render_markdown_content(processed_content.content, options)
            
            # 后处理链接（添加点击事件、样式等）
            final_html = self._post_process_links(html_content, processed_content.links)
            
            # 构建结果
            result = RenderResult(
                html=final_html,
                links=processed_content.links,
                processing_time_ms=(time.time() - start_time) * 1000,
                cache_hit=False
            )
            
            # 缓存结果
            self.render_cache.set(cache_key, {
                'html': result.html,
                'links': result.links,
                'processing_time_ms': result.processing_time_ms
            })
            
            return result
            
        except Exception as e:
            # 错误处理和降级
            return self._handle_render_error(e, content, file_path)
    
    def _render_markdown_content(self, content: str, options: Dict[str, Any]) -> str:
        """核心Markdown渲染逻辑"""
        # 使用选定的渲染器
        renderer = self._select_renderer(content, options)
        return renderer.render(content, options)
    
    def _post_process_links(self, html: str, links: List[LinkInfo]) -> str:
        """后处理链接，添加交互功能"""
        for link in links:
            if link.link_type == LinkType.EXTERNAL:
                # 为外部链接添加安全提示
                html = self._add_external_link_warning(html, link)
            elif link.link_type == LinkType.INTERNAL:
                # 为内部链接添加点击处理
                html = self._add_internal_link_handler(html, link)
            elif link.link_type == LinkType.ANCHOR:
                # 为锚点链接添加平滑滚动
                html = self._add_anchor_link_scroll(html, link)
        
        return html
```

#### 8.2.2 内容预览集成

**预览集成实现**：
```python
class EnhancedContentPreview:
    def __init__(self, link_processor: ILinkProcessor, file_resolver: IFileResolver):
        self.link_processor = link_processor
        self.file_resolver = file_resolver
        self.preview_cache = {}
    
    def generate_preview(self, file_path: Path, max_length: int = 500) -> ContentPreview:
        """生成增强的内容预览，包含链接信息"""
        try:
            # 读取文件内容
            content = self.file_resolver.read_file(file_path)
            
            # 处理链接
            processed_content = self.link_processor.process_links(content, file_path)
            
            # 生成预览文本
            preview_text = self._generate_preview_text(processed_content.content, max_length)
            
            # 提取关键链接
            key_links = self._extract_key_links(processed_content.links)
            
            # 构建预览结果
            preview = ContentPreview(
                file_path=file_path,
                preview_text=preview_text,
                links=key_links,
                link_count=len(processed_content.links),
                has_external_links=any(l.link_type == LinkType.EXTERNAL for l in processed_content.links),
                has_broken_links=any(not l.is_valid for l in processed_content.links),
                warnings=processed_content.warnings
            )
            
            # 缓存预览结果
            self._cache_preview(file_path, preview)
            
            return preview
            
        except Exception as e:
            return self._handle_preview_error(e, file_path)
    
    def _generate_preview_text(self, content: str, max_length: int) -> str:
        """生成预览文本"""
        # 移除Markdown标记
        clean_text = self._remove_markdown_syntax(content)
        
        # 截取指定长度
        if len(clean_text) <= max_length:
            return clean_text
        
        # 在合适的位置截断
        truncated = clean_text[:max_length]
        last_space = truncated.rfind(' ')
        if last_space > max_length * 0.8:  # 如果最后一个空格在80%位置之后
            truncated = truncated[:last_space]
        
        return truncated + '...'
    
    def _extract_key_links(self, links: List[LinkInfo]) -> List[LinkInfo]:
        """提取关键链接用于预览"""
        # 按重要性排序：内部链接 > 外部链接 > 锚点链接
        sorted_links = sorted(links, key=lambda l: self._get_link_priority(l))
        
        # 返回前5个最重要的链接
        return sorted_links[:5]
    
    def _get_link_priority(self, link: LinkInfo) -> int:
        """计算链接优先级"""
        priority_map = {
            LinkType.INTERNAL: 3,
            LinkType.EXTERNAL: 2,
            LinkType.ANCHOR: 1
        }
        return priority_map.get(link.link_type, 0)
```

### 8.3 缓存策略集成

#### 8.3.1 链接缓存管理

**链接专用缓存**：
```python
class LinkCacheManager:
    def __init__(self, cache_manager: ICacheManager):
        self.link_cache = cache_manager.get_cache('link')
        self.validation_cache = cache_manager.get_cache('validation')
        self.resolution_cache = cache_manager.get_cache('resolution')
    
    def cache_link_processing(self, content_hash: str, file_path: Path, 
                            processed_content: ProcessedContent):
        """缓存链接处理结果"""
        cache_key = f"link_processing:{content_hash}:{file_path}"
        self.link_cache.set(cache_key, {
            'links': processed_content.links,
            'warnings': processed_content.warnings,
            'processing_time_ms': processed_content.processing_time_ms,
            'timestamp': time.time()
        }, ttl=3600)  # 1小时过期
    
    def cache_link_validation(self, link: str, validation_result: LinkValidationResult):
        """缓存链接验证结果"""
        cache_key = f"link_validation:{hashlib.md5(link.encode()).hexdigest()}"
        self.validation_cache.set(cache_key, {
            'validation_result': validation_result,
            'timestamp': time.time()
        }, ttl=1800)  # 30分钟过期
    
    def cache_link_resolution(self, link: str, base_path: Path, 
                            resolved_link: ResolvedLink):
        """缓存链接解析结果"""
        cache_key = f"link_resolution:{hashlib.md5(link.encode()).hexdigest()}:{base_path}"
        self.resolution_cache.set(cache_key, {
            'resolved_link': resolved_link,
            'timestamp': time.time()
        }, ttl=7200)  # 2小时过期
    
    def get_cached_link_processing(self, content_hash: str, file_path: Path) -> Optional[ProcessedContent]:
        """获取缓存的链接处理结果"""
        cache_key = f"link_processing:{content_hash}:{file_path}"
        cached_data = self.link_cache.get(cache_key)
        
        if cached_data:
            return ProcessedContent(
                content="",  # 缓存中不存储原始内容
                links=cached_data['links'],
                warnings=cached_data['warnings'],
                processing_time_ms=cached_data['processing_time_ms'],
                cache_hit=True
            )
        
        return None
```

#### 8.3.2 缓存失效策略

**智能缓存失效**：
```python
class LinkCacheInvalidator:
    def __init__(self, cache_manager: ICacheManager):
        self.cache_manager = cache_manager
        self.file_link_mapping = {}  # 文件到链接的映射
    
    def register_file_links(self, file_path: Path, links: List[LinkInfo]):
        """注册文件的链接信息"""
        self.file_link_mapping[file_path] = links
    
    def invalidate_file_links(self, file_path: Path):
        """文件变化时失效相关链接缓存"""
        if file_path not in self.file_link_mapping:
            return
        
        links = self.file_link_mapping[file_path]
        
        # 失效链接处理缓存
        for link in links:
            self._invalidate_link_caches(link)
        
        # 清理文件链接映射
        del self.file_link_mapping[file_path]
    
    def _invalidate_link_caches(self, link: LinkInfo):
        """失效单个链接的所有缓存"""
        link_hash = hashlib.md5(link.link_url.encode()).hexdigest()
        
        # 失效验证缓存
        validation_key = f"link_validation:{link_hash}"
        self.cache_manager.get_cache('validation').delete(validation_key)
        
        # 失效解析缓存
        resolution_pattern = f"link_resolution:{link_hash}:*"
        self.cache_manager.get_cache('resolution').delete_pattern(resolution_pattern)
    
    def invalidate_external_link_caches(self, domain: str):
        """失效特定域名的外部链接缓存"""
        # 查找所有包含该域名的链接
        for file_path, links in self.file_link_mapping.items():
            for link in links:
                if (link.link_type == LinkType.EXTERNAL and 
                    domain in link.link_url):
                    self._invalidate_link_caches(link)
```

### 8.3.3 工具与错误引用示例（新增说明）

```python
# 示例：当缓存实现不支持 delete_pattern 时，使用通配删除工具
from cache.delete_pattern_utils import delete_pattern

# 假设 resolution_cache 实现 keys()/delete()
removed = delete_pattern(resolution_cache, "link_resolution:abc123:*")
print(f"Invalidated {removed} resolution keys")
```

```python
# 示例：统一使用核心异常，便于调用方捕获
from core.errors import FileReadError, ServiceNotFoundError, ErrorSeverity

try:
    content = file_resolver.read_file(path)
except FileReadError as e:
    logger.error(f"Read failed: {e}")
```

### 8.4 错误处理集成

#### 8.4.1 链接错误处理

**链接错误分类**：
```python
class LinkErrorHandler:
    def __init__(self, error_propagation_chain: ErrorPropagationChain):
        self.error_chain = error_propagation_chain
        self.link_error_stats = defaultdict(int)
    
    def handle_link_error(self, error: Exception, link: str, context: Dict[str, Any]) -> ErrorResult:
        """处理链接相关错误"""
        # 记录错误统计
        error_type = type(error).__name__
        self.link_error_stats[error_type] += 1
        
        # 构建错误上下文
        error_context = {
            'link': link,
            'error_type': error_type,
            'link_context': context,
            'error_count': self.link_error_stats[error_type]
        }
        
        # 通过错误传播链处理
        return self.error_chain.propagate_error(
            error, error_context, ['LinkProcessor', 'ErrorHandler']
        )
    
    def get_link_error_report(self) -> Dict[str, Any]:
        """获取链接错误报告"""
        total_errors = sum(self.link_error_stats.values())
        
        return {
            'total_errors': total_errors,
            'error_distribution': dict(self.link_error_stats),
            'error_rate': total_errors / max(1, self._get_total_link_operations()),
            'most_common_error': max(self.link_error_stats.items(), key=lambda x: x[1])[0] if self.link_error_stats else None
        }
    
    def _get_total_link_operations(self) -> int:
        """获取总链接操作数（估算）"""
        # 这里可以实现更复杂的统计逻辑
        return max(1, sum(self.link_error_stats.values()) * 10)
```

#### 8.4.2 降级策略集成

**链接处理降级**：
```python
class LinkProcessingFallback:
    def __init__(self):
        self.fallback_strategies = {
            LinkType.EXTERNAL: self._external_link_fallback,
            LinkType.INTERNAL: self._internal_link_fallback,
            LinkType.ANCHOR: self._anchor_link_fallback
        }
    
    def apply_fallback(self, link: LinkInfo, error: Exception) -> ProcessedLink:
        """应用链接处理降级策略"""
        fallback_strategy = self.fallback_strategies.get(link.link_type)
        
        if fallback_strategy:
            return fallback_strategy(link, error)
        
        # 默认降级策略
        return self._default_link_fallback(link, error)
    
    def _external_link_fallback(self, link: LinkInfo, error: Exception) -> ProcessedLink:
        """外部链接降级策略"""
        return ProcessedLink(
            original_link=link,
            processed_link=f"<span class='broken-link' title='链接不可用: {error}'>{link.link_text}</span>",
            is_valid=False,
            error_message=str(error),
            fallback_applied=True
        )
    
    def _internal_link_fallback(self, link: LinkInfo, error: Exception) -> ProcessedLink:
        """内部链接降级策略"""
        return ProcessedLink(
            original_link=link,
            processed_link=f"<span class='broken-internal-link' title='内部链接不可用: {error}'>{link.link_text}</span>",
            is_valid=False,
            error_message=str(error),
            fallback_applied=True
        )
    
    def _anchor_link_fallback(self, link: LinkInfo, error: Exception) -> ProcessedLink:
        """锚点链接降级策略"""
        return ProcessedLink(
            original_link=link,
            processed_link=f"<span class='broken-anchor-link' title='锚点链接不可用: {error}'>{link.link_text}</span>",
            is_valid=False,
            error_message=str(error),
            fallback_applied=True
        )
    
    def _default_link_fallback(self, link: LinkInfo, error: Exception) -> ProcessedLink:
        """默认降级策略"""
        return ProcessedLink(
            original_link=link,
            processed_link=f"<span class='broken-link' title='链接错误: {error}'>{link.link_text}</span>",
            is_valid=False,
            error_message=str(error),
            fallback_applied=True
        )
```

---

**文件状态**: 第8章完成 ✅  
**内容行数**: 约480行  
**下一步**: 生成第9-11章-实施规划 